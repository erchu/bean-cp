---
layout: default
---

<div id="page-main-content">
  		
  <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
  
  <section id="main-content-section">
	<h1>What is bean-cp?</h1>
	
	<p>
		Today modern applications usually contain more than one object model of the same real-life objects. The reason behind that
		approach is need for model optimization for specific use or system modularization. For example,
		<a href="http://en.wikipedia.org/wiki/Domain_model">domain model</a> could be used to organize your application logic and is mapped to
		<a href="http://en.wikipedia.org/wiki/Model_View_ViewModel">view models</a> optimized for UI layer</li>. Another example are
		<a href="http://en.wikipedia.org/wiki/Data_transfer_object">data transfer objects</a> &#8211; optimized model for transferring data over
		network and integration between systems using technologies like WebServices.
	</p>

	<p>The drawback of this approach is need for extra mapping code to map data between models. In fact those models are usually similar,
	so writing mapping code could be really boring. This is why mapping frameworks were invented.</p>
	
	<h2>Bean-cp is object to object mapping framework for Java</h2>
	
	<p>Library is targeted for Java version 8 to bring the power of lambda expressions to object mapping.</p>

	<p>Release 1.0.2 is <a href="download.html">available for download</a> and in Maven's central repository:</p>

	<pre class="brush: xml; gutter: false;">
&lt;dependency&gt;
	&lt;groupId&gt;com.github.erchu&lt;/groupId&gt;
	&lt;artifactId&gt;beancp&lt;/artifactId&gt;
	&lt;version&gt;1.0.2&lt;/version&gt;
&lt;/dependency&gt;
</pre>

	<h1>Why bean-cp?</h1>

	<h2>Easy to read and standardized mapping code</h2>
	
	<p>Lambda expressions and fluent API comes to play...</p>

<pre class="brush: java; gutter: false;">
Mapper mapper = new MapperBuilder()
    .addMap(Order.class, OrderOverviewDto.class, (conf, source, destination) -> conf
        .bind(source::getDate, destination::setDate)
        .bind(source::getPaymentDueDay, destination::setPaymentDueDay)
        .bind(source::getStatus, destination::setStatus)
        .bind(source::getTotal, destination::setTotal)
        .bind(source.getCustomer()::getName, destination::setCustomerName))
    .buildMapper();
</pre>
	
	<h2>Saves your time</h2>

	<p>Conventions feature lets you define mapping quickly. Above example can be fully replaced by convention:</p>

<pre class="brush: java; gutter: false;">
Mapper mapper = new MapperBuilder()
    .addMap(Order.class, OrderOverviewDto.class, (conf, source, destination) -> conf
        .useConvention(NameBasedMapConvention.get().enableFlattening()))
    .buildMapper();
</pre>
	
	<p>Both mechanism can be mixed:</p>
	
<pre class="brush: java; gutter: false;">
Mapper mapper = new MapperBuilder()
    .addMap(Order.class, OrderOverviewDto.class, (conf, source, destination) -> conf
        .useConvention(NameBasedMapConvention.get().enableFlattening())
        .bind(() -&gt; source.getStatus() == OrderStatus.OVERDUE, destination::isOverdue))
    .buildMapper();
</pre>
	
	<h2>Map anything</h2>

	<p>When you face non standard situation converters comes to rescue:</p>
	
<pre class="brush: java; gutter: false;">
Mapper mapper = new MapperBuilder()
	.addConverter(int.class, Range.class, source -> Range.of(source, Integer.MAX_VALUE))
	.buildMapper();
</pre>
	
	<h2>Extensibility</h2>

	<p>If you need something different than name-based convention you can implement your own mapping convention. See
	<a href="apidocs/release/1.0/com/github/erchu/beancp/MapConvention.html"><code>MapConvention</code></a>
	interface. In fact <a href="apidocs/release/1.0/com/github/erchu/beancp/commons/NameBasedMapConvention.html">
	<code>NameBasedMapConvention</code></a> is provided as implementation of this interface with no extra magic.</p>
	
	<pre class="brush: java; gutter: false;">
public interface MapConvention {

  /**
   * Returns list of bindings for specified source and destination classes. Must
   * be thread-safe.
   *
   * @param mappingsInfo current mapping information.
   * @param sourceClass source class.
   * @param destinationClass destination class.
   * @return found bindings.
   */
  List&lt;Binding&gt; getBindings(
      final MappingInfo mappingsInfo,
      final Class sourceClass,
      final Class destinationClass);
}
</pre>
	
	<h2>There is more</h2>
	
	<p>Bean-cp gives to you some useful utilities like common collections mapping or null substitution.</p>
	
	<h2>It is free for any use with source code publicly available</h2>

	<p>Bean-cp is licensed under LGPL 3.0, so you can use it for free both, for open source and commercial projects. Source code publicly
	available on GitHub and you are welcome to contribute to the project or create own fork.</p>
	
	<h1>License</h1>

	<p>Copyright (&copy;) 2014, Rafa≈Ç Chojnacki, All rights reserved.</p>

	<p>This library is free software; you can redistribute it and/or modify it under the terms of the <a href="https://www.gnu.org/licenses/lgpl-3.0.html">
	GNU Lesser General Public License as published by the Free Software Foundation; either version 3.0 of the License</a>, or (at your option) any later
	version.</p>

	<p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
	FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p>
  </section>
  <section id="right-content-section">
	<div id="quick-step-panel">
		<a href="download/release/1.0.2/beancp-1.0.2-all.zip">Download</a>
		<a href="user-manual.html">Get started with user manual</a>
	</div>
	<div id="project-maintenance-info">
		<p><a href="https://github.com/erchu/bean-cp/">View the Project on GitHub</a></p>
	</div>
  </section>
</div>
