<div id="page-main-content">
	<section id="main-content-section">
		<h1>User manual</h1>
		
		<p>This user manual describes how to set up and use bean-cp library. It covers all available features. Before you start you have to
		have good knowledge of Java programming language version 8 including lambda expressions. If you get any trouble please checkout
		<a href="#support">support</a> page.</p>
		
		<p>Source code of examples from this tutorial is
		<a href="https://github.com/erchu/bean-cp/tree/gh-pages/sample-source-code/src/com/github/erchu/beancp/tutorial">available on GitHub</a>
		(for browse and for download).</p>
		
		<h2 id="setting-up">Setting up environment</h2>
		
		<p>Firstly, bean-cp requires Java version 8 or later. If you do not have it please download it from
		<a href="http://www.oracle.com/technetwork/java/javase/overview/index.html">Oracle website</a>, install and then continue with this
		user manual.</p>
		
		<p>You have generally two options to get a copy of bean-cp:</p>
		
		<ol>
			<li><strong>Download it from this website.</strong> Note that bean-cp has two dependencies: Apache Commons Lang and Javassist.
			File <a href="download/release/1.0.1/beancp-1.0.1-all.zip">beancp-1.0.1-all.zip</a> contains library and all dependencies. Otherwise
			you can download from this site only <a href="download/release/1.0.1/beancp-1.0.1.jar">beancp-1.0.1.jar</a> and get
			dependencies from another source.</li>
			<li><strong>Use build system like Maven.</strong> The artifacts can be found in Maven's central repository.
			Dependency declaration:
<pre class="brush: xml; gutter: false;">
&lt;dependency&gt;
	&lt;groupId&gt;com.github.erchu&lt;/groupId&gt;
	&lt;artifactId&gt;beancp&lt;/artifactId&gt;
	&lt;version&gt;1.0.1&lt;/version&gt;
&lt;/dependency&gt;</pre>
			</li>
		</ol>
		
		<p>If you want to use different version of Apache Commons Lang or Javassist the recommended way is to download
		<a href="download/release/1.0.1/beancp-1.0.1-sources.jar">bean-cp source code</a> and execute all bean-cp unit tests against versions you would
		like to use to prove compatibility.</p>
		
		<h2 id="first-mapping">First mapping</h2>
		
		<p>There are few mapping scenarios supported. We will start with <strong>declarative map</strong> used to map from one
		<a href="http://en.wikipedia.org/wiki/JavaBeans">JavaBean</a> to another JavaBean.</p>

		<p>Let's start with simple example. Suppose we have following two classes in our domain model:</p>
		
<pre class="brush: java; gutter: false;">
public class Customer {
		
	private long id;
	
	private String fullName;

	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

	public String getFullName() {
		return fullName;
	}

	public void setFullName(String fullName) {
		this.fullName = fullName;
	}
}

public class Order {
	
	private long id;
	
	private Customer customer;
	
	private BigDecimal totalAmount;

	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

	public Customer getCustomer() {
		return customer;
	}

	public void setCustomer(Customer customer) {
		this.customer = customer;
	}

	public BigDecimal getTotalAmount() {
		return totalAmount;
	}

	public void setTotalAmount(BigDecimal totalAmount) {
		this.totalAmount = totalAmount;
	}
}</pre>

		<p>Our task is to map <code>Order</code> to <code>OrderDto</code>:</p>
		
<pre class="brush: java; gutter: false;">
public static class OrderOverviewDto {
	
	private long id;
	
	private String customerFullName;
	
	private BigDecimal totalAmount;

	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

	public String getCustomerFullName() {
		return customerFullName;
	}

	public void setCustomerFullName(String customerFullName) {
		this.customerFullName = customerFullName;
	}

	public BigDecimal getTotalAmount() {
		return totalAmount;
	}

	public void setTotalAmount(BigDecimal totalAmount) {
		this.totalAmount = totalAmount;
	}
}</pre>

	<p>Hare is how to do that in bean-cp way:

<pre class="brush: java">
Mapper mapper
	= new MapperBuilder()
	.addMap(
		Order.class,
		OrderOverviewDto.class,
		(conf, source, destination) -> conf
			.bind(source::getId, destination::setId)
			.bind(source.getCustomer()::getFullName, destination::setCustomerFullName)
			.bind(source::getTotalAmount, destination::setTotalAmount))
	.buildMapper();
</pre>
		
		<p>There are three steps:</p>
		
		<ol>
			<li><strong>Configure mapper using <a href="apidocs/release/1.0/com/github/erchu/beancp/MapperBuilder.html">MapperBuilder</a></strong>.
				To configure mapper you need to create instance of <a href="apidocs/release/1.0/com/github/erchu/beancp/MapperBuilder.html">MapperBuilder</a>
				(line 2) and add one or mapping configurations (line 3 - 9). Each mapping configuration declares source and destination class (<code>Order</code> and
				<code>OrderOverviewDto</code> in our example). Source and destination classes must have default (with no arguments) public
				or protected constructor, must have not been final and cannot be inner non-static classes. There are three options to add mapping configuration:
				declarative map, converter and convention. In this section we will focus on declarative maps. They are used to map from one JavaBean to another.
				To add declarative map call
				<a href="apidocs/release/1.0/com/github/erchu/beancp/MapperBuilder.html#addMap-java.lang.Class-java.lang.Class-com.github.erchu.beancp.DeclarativeMapSetup-"><code>addMap()</code></a>
				method (line 3). This method takes three parameters: source class (in our example: <code>Order</code>), destination class (in our example:
				<code>OrderOverviewDto</code>) and map declaration. Map declaration is lambda expression taking three parameters: configuration reference,
				source object reference and destination object reference (line 6). Finally we define map using series of operations like binding from source
				member to destination member using
				<a href="apidocs/release/1.0/com/github/erchu/beancp/DeclarativeMap.html#bind-java.util.function.Supplier-java.util.function.Consumer-com.github.erchu.beancp.BindingOption...-"><code>bind()</code></a>
				(line 7, 8 and 9).</li>
			<li><strong>Build mapper from configuration</strong>. Call
				<a href="apidocs/release/1.0/com/github/erchu/beancp/MapperBuilder.html#buildMapper--">buildMapper()</a> method to get
				<a href="apidocs/release/1.0/com/github/erchu/beancp/Mapper.html">Mapper</a> instance (line 10).</li>
			<li><strong>Preform mappings</strong> using <code>Mapper</code> instance. Let see how to perform mapping using
				<a href="apidocs/release/1.0/com/github/erchu/beancp/Mapper.html"><code>Mapper</code></a>. There are two options here. If you already
				have destination object instance and only want to fill it with data from source object then you write code
				like this:
		
<pre class="brush: java; gutter: false;">
	Order order = new Order();
	OrderOverviewDto destination = new OrderOverviewDto();
	
	// Some other stuff here
	
	mapper.map(order, destination);
</pre>

		Otherwise bean-cp can create destination object instance for you:
		
<pre class="brush: java; gutter: false;">
	Order order = new Order();
	
	// Some other stuff here
	
	OrderOverviewDto destination = mapper.map(order, OrderOverviewDto.class);
</pre>

			</li>
		</ol>

		<p>That's it! First mapping is ready.</p>

		<h2 id="declarative-maps">Declarative maps in deep</h2>
		
		<h3 id="bind-constant">Bind constant</h3>

		<p>Destination member can be bind to constant using <code>bindConstant</code>. For example
		<code>bindConstant("", destination::setCustomerFullName)</code> will bind empty string to <code>customerFullName</code> property.</p>
		
		<h3 id="calculated-members">Calculated members</h3>
		
		<p>Method <code>bind</code> supports also calculated members. For example:</p>

<pre class="brush: java; gutter: false;">
	bind(
		() -> source.getTotalAmount().setScale(2, RoundingMode.CEILING),
		destination::setTotalAmount)
</pre>

		<p>calculates rounded value of <code>totalAmount</code> value. Note that name of <code>setScale</code> method of <code>BigDecimal</code>
		class can be misleading, because it do not modifies current instance but returns new one (see
		<a href="http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#setScale(int,%20java.math.RoundingMode)">Java Platform API specification</a>).
		Term "calculated member" is not limited to mathematical calculations &#8211; any expression which returns value of proper type can be used. Those
		calculation should have no side effects, especially should not modify source object.</p>
		
		<h3 id="conditional-mapping">Conditional mapping</h3>
		
		<p>Moreover <code>bind</code> and <code>bindConstant</code> methods support <code>BindingOptions</code>. This allows to perform conditional
		mappings and null substitution. Mapping condition defines when to execute mapping. For example following binding will map only positive
		values of <code>totalAmount</code> property:</p>
		
<pre class="brush: java; gutter: false;">
	bind(
		source::getTotalAmount,
		destination::setTotalAmount,
		BindingOption.mapWhen(() -> source.getTotalAmount().compareTo(BigDecimal.ZERO) > 0)
</pre>

		<h3 id="null-substitution">Null substitution</h3>

		<p>Binding options can be also used to substitute <code>null</code> value with specified value. For example following binding will substitute
		<code>null</code> value with <code>"unknown"</code> string.</p>

<pre class="brush: java; gutter: false;">
	bind(
		source.getCustomer()::getFullName,
		destination::setCustomerFullName,
		BindingOption.withNullSubstitution("unknown"))
</pre>

		<h3 id="map-inner-objects">Map inner objects</h3>

		<p>Suppose we have in our application classes presented on the below diagram:</p>
		
		<img src="images/user-manual/diagram1.png" width="679" height="171" />
		
		<p>Now suppose you want to map <code>Line</code> to this model:</p>
		
		<img src="images/user-manual/diagram2.png" width="479" height="162" />
		
		<p>What is new about this situation (comparing to previous examples) is need for inner object mapping (object graph in other words).
		<code>LineDto</code> do not references <code>Point</code>, but references <code>PointDto</code>. This means that we need to map
		<code>Point</code> to <code>PointDto</code> in first step and then map <code>Line</code> to <code>LineDto</code>. Our map configuration
		should look like this:</p>

<pre class="brush: java;">
	Mapper mapper = new MapperBuilder()
		.addMap(Point.class, PointDto.class, (conf, source, destination) -> conf
			.bind(source::getX, destination::setX)
			.bind(source::getY, destination::setY))
		.addMap(Line.class, LineDto.class, (conf, source, destination) -> conf
			.mapInner(source::getStart, destination::setStart, PointDto.class)
			.mapInner(source::getEnd, destination::setEnd, PointDto.class))
		.buildMapper();
</pre>

		<p>In line 6 and 7 <code>mapInner</code> operation is used to map <code>Point</code> to <code>PointDto</code> and then assign it to proper
		<code>LineDto</code>'s property. If you do not want to always create new <code>PointDto</code> but map to existing one you will need to
		additionally provide destination's member getter:</p>

<pre class="brush: java; gutter: false;">
	.mapInner(source::getStart, destination::setStart, destination::getStart, PointDto.class)
	.mapInner(source::getEnd, destination::setEnd, destination::getEnd, PointDto.class))
</pre>

		<h3 id="destination-object-construction">Destination object construction</h3>

		<p>As was already mentioned bean-cp can create destination object during mapping:</p>
		
<pre class="brush: java; gutter: false;">
	OrderOverviewDto destination = mapper.map(order, OrderOverviewDto.class);
</pre>

		<p>By default objects are constructed using no-argument constructor. This could be changed using <code>constructDestinationObjectUsing</code>
		declaration. For example suppose that exists <code>OrderOverviewDtoFactory</code> which should be used to construct <code>OrderOverviewDto</code>
		objects. Here is how to use <code>constructDestinationObjectUsing</code> in that situation (line 5 - 9):</p>
		
<pre class="brush: java; gutter: false;">
	Mapper mapper = new MapperBuilder().addMap(
		Order.class,
		OrderOverviewDto.class,
		(conf, source, destination) -> conf
				.constructDestinationObjectUsing(() -> {
					OrderOverviewDto result = OrderOverviewDtoFactory.getOrderOverviewDto();

					return result;
				})
				// and so on...
</pre>

		<p>Be aware that <code>constructDestinationObjectUsing</code> must be first statement before <code>bind</code> and <code>bindConstant</code>
		statements.</p>

		<h3 id="before-after-map">Before and after map actions</h3>

		<p>There are situations when you need to perform an operation before or after mapping. Here is proper code snipped to do that:</p>

<pre class="brush: java; gutter: false;">
	Mapper mapper = new MapperBuilder().addMap(
			Order.class,
			OrderOverviewDto.class,
			(conf, source, destination) -> conf
				.beforeMap(() -> Logger.debug(
					"Starting mapping of Order (id: "
					+ source.getId() + ")"))
				
				// Some other stuff here...
				
				.afterMap(() -> Logger.debug(
					"Finished mapping of Order (id: "
					+ source.getId() + ")"))
					
				// and so on...
</pre>
	
		<p>You can also use mapper reference in "before" and "after" actions:</p>
	
<pre class="brush: java; gutter: false;">
	Mapper mapper = new MapperBuilder().addMap(
			Order.class,
			OrderOverviewDto.class,
			(conf, source, destination) -> conf
				.beforeMap(mapperRef -> Logger.debug(
					"Starting mapping of Order (id: "
					+ source.getId()
					+ ") by mapper "
					+ mapperRef))
				
				// Some other stuff here...
				
				.afterMap(mapperRef -> Logger.debug(
					"Finished mapping of Order (id: "
					+ source.getId()
					+ ") by mapper "
					+ mapperRef))
					
				// and so on...
</pre>
		<h3 id="field-binding">Field binding</h3>

		<p>In case you need to bind some fields (in example: <code>sourceMember</code> field to <code>destinationMember</code> field):</p>
		
<pre class="brush: java; gutter: false;">
	.bind(() -> { return source.sourceMember; }, v -> { destination.destinationMember = v; })
</pre>

		<h3 id="declarative-map-statement-order">Statement order</h3>
		
		<p>Finally, please note that methods must be executed in the following order:</p>
		
		<ul>
			<li><code>constructDestinationObjectUsing</code> zero or one time</li>
			<li><code>beforeMap</code> zero or many times</li>
			<li><code>useConvention</code> zero or one time (<a href="#user-manual,conventions">conventions are discussed later</a>)</li>
			<li><code>bind</code> and <code>bindConstant</code> and <code>mapInner</code> methods zero or many times in any order</li>
			<li><code>afterMap</code> zero or many times</li>
		</ul>

		<h2 id="converters">Converters</h2>
		
		<h3 id="when-and-how-to-create-converters">When and how to create converter?</h3>

		<p>Time to time you will need to map from or to object which is not JavaBean. There are also situations when object do not have
		default public or protected constructor. For those kind of objects you will need to write <strong>converter</strong>. Then converters
		can be used to map inner objects just like we did in "<a href="#user-manual,map-inner-objects">Map inner objects" section</a>.
		Good example of valid converter usage is conversion to <a href="http://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html">LocalDate</a>.
		LocalDate is <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/doc-files/ValueBased.html">value-based</a> class, so it is
		immutable, do not have accessible constructors, and instances are instead instantiated through factory methods. It is <strong>not</strong>
		a JavaBean.</p>
		
		<p>When you use converter you generally need to write conversion code by your self. For example this code converts
		<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Date.html">Date</a> to
		<a href="http://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html">LocalDate</a>.</p>

<pre class="brush: java; gutter: false;">
	Date input = // ...
	Instant instant = source.toInstant();
	ZonedDateTime zonedDateTime = instant.atZone(ZoneId.systemDefault());
	LocalDate result = zonedDateTime.toLocalDate();
</pre>

		<p>Here is example how to make and register converter:</p>

<pre class="brush: java; gutter: false;">
	Mapper mapper = new MapperBuilder()
		.addConverter(Date.class, LocalDate.class, source -> {
			Instant instant = source.toInstant();
			ZonedDateTime zonedDateTime = instant.atZone(ZoneId.systemDefault());
			LocalDate result = zonedDateTime.toLocalDate();

			return result;
		}).buildMapper();
</pre>

		<p>There are few other <code>addConverter</code> methods, but idea is generally similar. For details please have a look at
		<a href="http://localhost:8888/apidocs/release/1.0/com/github/erchu/beancp/MapperBuilder.html">MapperBuilder API specification</a>.</p>

		<h3 id="common-converters">Common converters</h3>

		<p>There are two sets of converters provided with bean-cp: <code>CollectionConverters</code> and <code>NumberConverters</code>.</p>
		
		<p>Conversion from array to collection:</p>
		
<pre class="brush: java; gutter: false;">
	Mapper mapper = new MapperBuilder()
		.addConverter(CollectionConverters.getArrayToCollection(long.class))
		.buildMapper();

	Collection&lt;?&gt; result = mapper.map(new long[] { 1, 2, 3 }, Collection.class);
</pre>
		
		<p>Conversion from collection to array:</p>
		
<pre class="brush: java; gutter: false;">
	Mapper mapper = new MapperBuilder()
		.addConverter(CollectionConverters.getCollectionToArray(String.class))
		.buildMapper();

	Collection&lt;String&gt; collectionInstance = // ...

	String[] result = mapper.map(collectionInstance, String[].class);
</pre>
		
		<p>Number conversion:</p>

<pre class="brush: java; gutter: false;">
	Mapper mapper = new MapperBuilder()
		.addConverter(NumberConverters.get())
		.buildMapper();

	Double result = mapper.map(1l, Double.class);
</pre>

		<h2 id="conventions">Conventions</h2>

		<p>If you plan to use bean-cp then your application probably contain more than one object model of the same real-life objects.
		If those models are similar this could result in sequence of code like this:</p>

<pre class="brush: java; gutter: false;">
Mapper mapper
	= new MapperBuilder()
	.addMap(
		UserDto.class,
		User.class,
		(conf, source, destination) -> conf
			.bind(source::getId, destination::setId)
			.bind(source::getFirstName, destination::setFirstName)
			.bind(source::getLastName, destination::setLastName)
			.bind(source::getPassword, destination::setPassword)
			.bind(source::getPhoneNumber, destination::setPhoneNumber)
			.bind(source::getEmailAddress, destination::setEmailAddress))
	.buildMapper();
</pre>

		<p>In this case it is easy to find out that there is general pattern for matching source and destination properties: bind properties
		of the same name. In bean-cp component generating bindings according to some patterns is named <strong>convention</strong>. In other
		words convention analyse source and destination class structure and generates list of bindings.</p>
		
		<h3 id="name-based-convention">Name-based convention</h3>
		
		<p>Currently bean-cp provides one <strong>name-based convention</strong> which matches properties and fields by name (you could also
		write your own convention &#8211; see "<a href="#user-manual,write-convention">Write your own convention</a>").</p>
		
		<p>OK... so how to replace series of <code>bind</code> operations from last code listing with convention? Use
		<code>useConvention(NameBasedMapConvention.get())</code> method. Full example:</p>
		
<pre class="brush: java; gutter: false;">
Mapper mapper = new MapperBuilder()
	.addMap(User.class, UserDto.class, (conf, source, destination) -> conf
		.useConvention(NameBasedMapConvention.get()))
	.buildMapper();
</pre>

		<p>If some property is of different type at source than at destination then convention will try to map this inner type in first step. For
		example if <code>source::getEmailAddress</code> returns <code>EmailAddress</code> class instance and you registered converter from
		<code>EmailAddress</code> to <code>String</code> and <code>destination::setEmailAddress</code> accepts <code>String</code> then
		convention will convert instance of <code>EmailAddress</code> to <code>String</code> in first step and then assign result of
		this conversion to <code>emailAddress</code> property at destination.</p>
		
		<p><strong>Flattening feature.</strong> Name-based convention has few options. One of them is flattening feature. Let's consider
		following <code>bind</code> instruction.</p>

<pre class="brush: java; gutter: false;">
.bind(source.getPrimaryCustomer()::getName, destination::setPrimaryCustomerName)
</pre>

		<p>Above we bind <code>name</code> property to <code>primaryCustomerName</code>. Properties' names are different, but if we take into
		consideration full "path" then we notice that <code>"primaryCustomer" + "name" = "primaryCustomerName"</code> (ignoring case). To recognize
		such patterns we need to enable flattening feature:</p>
		
<pre class="brush: java; gutter: false;">
.useConvention(NameBasedMapConvention.get().enableFlattening())
</pre>
		
		<p><strong>Mix convention with declarative map.</strong> Conventions can be mixed with regular <code>bind</code>, <code>bindConstant</code>
		and <code>mapInner</code> instructions. For example:</p>
		
<pre class="brush: java; gutter: false;">
Mapper mapper = new MapperBuilder()
	.addMap(User.class, UserDto.class, (conf, source, destination) -> conf
		.useConvention(NameBasedMapConvention.get())
		.bind(
			() -> source.getFirstName() + ' ' + source.getLastName(),
			destination::setFullName))
	.buildMapper();
</pre>

		<p><strong>Controlling field/properties mapped by convention.</strong> There is option is used to control which fields and properties should be mapped
		by convention:</p>
		
		<ul>
			<li><code>includeDestinationMembers</code> &#8211 sets list of destination members which will be included by convention. Each entry must be
			regular expression matching field name or bean property name (according to
			<a href="http://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html">beans specification</a>). If not specified (empty array) all members
			are subject to map by convention. If specified (not empty array) only selected members could be mapped by convention. This list has lower priority that
			exclude list specified by <code>excludeDestinationMembers</code> method. Note that when you
			put some member on list then it is not guaranteed that it will be mapped â€” it still have to have matching source's member according to convention
			configuration.</li>
			<li><code>excludeDestinationMembers</code> &#8211 sets list of destination members which will be excluded (ignored) by convention. Each entry
			must be regular expression matching field name or bean property name (according to
			<a href="http://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html">beans specification</a>). This list has higher priority that
			include list specified by <code>includeDestinationMembers</code> method.</li>
		</ul>

		<h3 id="conventions-save-for-refactoring">How to make conventions ready for refactoring?</h3>
		
		<p>Conventions are probably the most important feature of bean-cp because they lets you speed up your development.
		However there is drawback of this approach: your refactoring tools are not aware of convention. In above example if you change
		<code>setEmailAddress</code> to <code>setEmail</code> and then e-mail address become unmapped. For large applications this
		could be a problem. Here are few tips how to deal with this problem:</p>
		
		<ol>
			<li>Use conventions only at prototype stage and then replace them with regular declarative maps.</li>
			<li>Write unit tests for your mappings. This is somehow controversial because you speed up development of mapping code, but you spend
			time at writing low priority unit tests. If the only reason to write such tests is use of convention you probably should not use convention
			at all.</li>
			<li>
				Check if all properties are mapped using <code>failIfNotAllDestinationMembersMapped</code> or <code>failIfNotAllSourceMembersMapped</code>
				depending on situation. If some properties are mapped by <code>bind</code>, <code>bindConstant</code> or <code>mapInner</code> instructions
				you need to exclude it explicitly by convention. Then write simple unit test checking if mapping configuration is valid.
			
<pre class="brush: java; gutter: false;">
public class MapperProvider {

	@SuppressWarnings("unchecked")
	public Mapper getMapper() {
		return new MapperBuilder()
		.addMap(User.class, UserDto.class, (conf, source, destination) -> conf
			.useConvention(NameBasedMapConvention.get()
				.excludeDestinationMembers("FullName")
				.failIfNotAllDestinationMembersMapped())
			.bind(
				() -> source.getFirstName() + ' ' + source.getLastName(),
				destination::setFullName))
		.buildMapper();
	}
}

public class MapperProviderTest {

	@Test
	public void mapper_configuration_is_valid() {
		// This test only check if getMapper() will not throw any exception
		new MapperProvider().getMapper();
	}
}
</pre>

			</li>
		</ol>

		<h3 id="map-any">Map any convention</h3>

		<p>What is more you can define (one or more) conventions used only if no specific mapping from type any A to B is defined:</p>

<pre class="brush: java; gutter: false;">
Mapper mapper = new MapperBuilder()
	.addMapAnyByConvention(NameBasedMapConvention.get())
	.buildMapper();
</pre>
		
		<h3 id="write-convention">Write your own convention</h3>

		<p>It is really easy. You need to only implement <code>MapConvention</code> interface:</p>

<pre class="brush: java; gutter: false;">
public interface MapConvention {
 
  /**
   * Returns list of bindings for specified source and destination classes. Must
   * be thread-safe.
   *
   * @param mappingsInfo current mapping information.
   * @param sourceClass source class.
   * @param destinationClass destination class.
   * @return found bindings.
   */
  List&lt;Binding&gt; getBindings(
      final MappingInfo mappingsInfo,
      final Class sourceClass,
      final Class destinationClass);
}
</pre>

		<p>Implementation must be thread-safe. Be aware that <code>Binding</code> class has two subclasses available
		<code>BindingWithValueConversion</code>, <code>BindingWithValueMap</code> and you can write your own if you need to.</p>

		<h2 id="big-example">Put it all together</h2>

		<p>Where are almost done. What I like to show you to sum up is bigger example combining features already described in this user
		manual. If you are not interested in such example please skip this section, but do not forget to read
		<a href="#user-manual,summary">summary</a> section.</p>

<pre class="brush: java; gutter: false;">
package com.github.erchu.beancp.tutorial;

import java.util.Collection;
import java.util.Date;
import java.util.LinkedList;
import java.util.Random;
import java.util.concurrent.ExecutionException;

import org.junit.Test;

import com.github.erchu.beancp.Mapper;
import com.github.erchu.beancp.MapperBuilder;
import com.github.erchu.beancp.commons.CollectionConverters;
import com.github.erchu.beancp.commons.NameBasedMapConvention;
import com.github.erchu.beancp.commons.NumberConverters;

public class _21_Conventions_Put_it_all_together {

    public static class AuditLog {  // Test addMapAnyByConvention

        private Date createdOn;

        private Date updatedOn;

        public Date getCreatedOn() {
            return createdOn;
        }

        public void setCreatedOn(Date createdOn) {
            this.createdOn = createdOn;
        }

        public Date getUpdatedOn() {
            return updatedOn;
        }

        public void setUpdatedOn(Date updatedOn) {
            this.updatedOn = updatedOn;
        }
    }

    public static class AuthorInfo {    // Test converter (to String)

        private String name;

        public static AuthorInfo getFromName(final String name) {
            AuthorInfo result = new AuthorInfo();
            result.name = name;

            return result;
        }

        public String getName() {
            return name;
        }
    }

    public static class PointExtension {    // Test flattening

        private Long z;     // Test NumberConverter

        private final Collection&lt;Integer&gt; otherDimensions;  // Test CollectionConverters

        public PointExtension() {
            this.otherDimensions = new LinkedList&lt;&gt;();
        }

        public Collection&lt;Integer&gt; getOtherDimensions() {
            return otherDimensions;
        }

        public Long getZ() {
            return z;
        }

        public void setZ(Long z) {
            this.z = z;
        }
    }

    public static class Point {     // Test NameBasedConvention, including
        							// failIfNotAllDestinationMembersMapped option

        private int x;  // Test DeclarativeMap.bind()

        public int y;  // Test DeclarativeMap.bind()

        private AuthorInfo author;

        private AuditLog audit;

        private PointExtension extension;

        public AuditLog getAudit() {
            return audit;
        }

        public void setAudit(AuditLog audit) {
            this.audit = audit;
        }

        public int getX() {
            return x;
        }

        public void setX(int x) {
            this.x = x;
        }

        public PointExtension getExtension() {
            return extension;
        }

        public void setExtension(PointExtension extension) {
            this.extension = extension;
        }

        public AuthorInfo getAuthor() {
            return author;
        }

        public void setAuthor(AuthorInfo author) {
            this.author = author;
        }
    }

    public static class PointInfo {

        private int metric;

        private int extensionZ;

        private int[] extensionOtherDimensions;

        private String author;

        private AuditLogInfo audit;

        public AuditLogInfo getAudit() {
            return audit;
        }

        public void setAudit(AuditLogInfo audit) {
            this.audit = audit;
        }

        public String getAuthor() {
            return author;
        }

        public void setAuthor(String author) {
            this.author = author;
        }

        public int getMetric() {
            return metric;
        }

        public void setMetric(int metric) {
            this.metric = metric;
        }

        public int getExtensionZ() {
            return extensionZ;
        }

        public void setExtensionZ(int extensionZ) {
            this.extensionZ = extensionZ;
        }

        public int[] getExtensionOtherDimensions() {
            return extensionOtherDimensions;
        }

        public void setExtensionOtherDimensions(int[] extensionOtherDimensions) {
            this.extensionOtherDimensions = extensionOtherDimensions;
        }
    }

    public static class AuditLogInfo {

        private Date createdOn;

        private Date updatedOn;

        public Date getCreatedOn() {
            return createdOn;
        }

        public void setCreatedOn(Date createdOn) {
            this.createdOn = createdOn;
        }

        public Date getUpdatedOn() {
            return updatedOn;
        }

        public void setUpdatedOn(Date updatedOn) {
            this.updatedOn = updatedOn;
        }
    }

    private final Random random = new Random();

	@Test
    @SuppressWarnings("unchecked")
    public void mapper_should_map_objects_in_parallel_threads()
            throws InterruptedException, ExecutionException {
        // Configure mapper
        Mapper mapper = new MapperBuilder()
                .addMapAnyByConvention(NameBasedMapConvention.get())
                .addConverter(AuthorInfo.class, String.class, source -&gt; {
                    return source.getName();
                })
                .addConverter(CollectionConverters.getCollectionToArray(int.class))
                .addConverter(NumberConverters.get())
                .addMap(
                        Point.class,
                        PointInfo.class,
                        (config, source, destination) -&gt; config
                        .useConvention(NameBasedMapConvention.get()
                                .enableFlattening()
                                .excludeDestinationMembers("metric")
                                .failIfNotAllDestinationMembersMapped())
                        .bind(() -&gt; source.getX() + source.y, destination::setMetric))
                .buildMapper();
        
        // Sample data

        PointExtension pointExtension = new PointExtension();
        pointExtension.setZ((long) random.nextInt());

        int otherDimensionNumber = random.nextInt(10);

        for (int i = 0 ; i &lt; otherDimensionNumber ; i++) {
            pointExtension.getOtherDimensions().add(i);
        }

        Point source = new Point();
        source.setX(random.nextInt());
        source.y = random.nextInt();
        source.setExtension(pointExtension);
        source.setAuthor(AuthorInfo.getFromName("U" + random.nextInt()));

        AuditLog auditLog = new AuditLog();
        auditLog.setCreatedOn(new Date());
        auditLog.setUpdatedOn(new Date());

        source.setAudit(auditLog);

        // Map
        @SuppressWarnings("unused")
        PointInfo result = mapper.map(source, PointInfo.class);
    }
}
</pre>

		<h2 id="summary">Summary</h2>

		<p>bean-cp is relatively new library, so your freedback and any other contribution is very, very important. If you have any thoughts
		about bean-cp please share them with us on <a href="https://groups.google.com/forum/#!forum/beancp">bean-cp
		project forum</a> on "<a href="https://groups.google.com/forum/#!topic/beancp/l47g0x5gOPg">What do you think about bean-cp?</a>" thread.</p>
		
		<p>One more thing. Apart of user manual you may also find helpful to read unit tests source code included in
		<a href="download/release/1.0.1/beancp-1.0.1-sources.jar">beancp-1.0.1-sources.jar</a></p>
	</section>
	<section class="table-of-contents">
		<!-- Content is generated dynamically -->
	</section>
	
    <script src="js/user-manual.js"></script>
</div>
